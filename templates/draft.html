{% extends "base.html" %}

{% block title %}{{ app_title }} - Interactive Draft{% endblock %}

{% block content %}
<!-- Draft State Container -->
<div id="draftContainer">
    <!-- Header -->
    <header class="header">
        <h1>üìã <span id="leagueName">{{ league_meta.league_name }}</span> - Live Draft</h1>
        <p class="subtitle" id="currentWeek">{{ league_meta.current_week }}</p>
        <div class="draft-status">
            <span id="draftStatus" class="status-indicator">Loading...</span>
            <span class="last-updated">Last Updated: <span id="lastUpdated">{{ league_meta.last_updated }}</span></span>
        </div>
    </header>

    <!-- Owner Selector Section -->
    <section class="owner-selector-section">
        <div class="owner-selector-card">
            <label for="ownerSelect" class="owner-label">
                <span class="label-icon">üë§</span>
                Select Your Name:
            </label>
            <select id="ownerSelect" class="owner-select">
                <option value="">-- Choose your name --</option>
                {% for team in teams %}
                <option value="{{ team.owner_name }}">{{ team.owner_name }} ({{ team.team_name }})</option>
                {% endfor %}
            </select>
            <p class="owner-hint">Select your name to enable drafting</p>
        </div>
    </section>

    <!-- Current Pick Banner -->
    <section class="current-pick-banner" id="currentPickBanner">
        <div class="banner-content">
            <div class="pick-info">
                <span class="pick-label">ON THE CLOCK:</span>
                <span class="pick-owner" id="currentPickOwner">Loading...</span>
            </div>
            <div class="pick-details">
                <span id="pickDetails">Round -, Pick -</span>
            </div>
        </div>
    </section>

    <!-- Roster Grid -->
    <section class="roster-grid-section">
        <h2>üìä Your Roster</h2>
        <div id="rosterGrid" class="roster-grid">
            <p class="loading-message">Select your name to view roster...</p>
        </div>
    </section>

    <!-- Snake Draft Board Section -->
    <section class="snake-draft-section">
        <div class="snake-header">
            <h2>üêç Snake Draft Board</h2>
            <div class="draft-legend">
                <span class="legend-item"><span class="legend-dot qb"></span> QB</span>
                <span class="legend-item"><span class="legend-dot rb"></span> RB</span>
                <span class="legend-item"><span class="legend-dot wr"></span> WR</span>
                <span class="legend-item"><span class="legend-dot te"></span> TE</span>
                <span class="legend-item"><span class="legend-dot other"></span> K/DST</span>
            </div>
        </div>
        <div id="snakeDraftBoard" class="snake-draft-board">
            <p class="loading-message">Loading draft board...</p>
        </div>
    </section>

    <!-- Recent Picks Feed (Side Panel) 
    <aside class="recent-picks-feed" id="recentPicksFeed">
        <h3>üìú Recent Picks</h3>
        <div id="recentPicksList" class="recent-picks-list">
            <p class="empty-message">No picks yet</p>
        </div>
    </aside>-->

    <!-- Available Players Section -->
    <section class="available-players-section">
        <h2>üéØ Available Players</h2>
        
        <!-- Filters -->
        <div class="player-filters">
            <div class="filter-group">
                <label for="positionFilter">Position:</label>
                <select id="positionFilter" class="filter-select">
                    <option value="">All Positions</option>
                    <option value="QB">QB</option>
                    <option value="RB">RB</option>
                    <option value="WR">WR</option>
                    <option value="TE">TE</option>
                    <option value="K">K</option>
                    <option value="DST">DST</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="searchInput">Search:</label>
                <input type="text" id="searchInput" class="search-input" placeholder="Player name...">
            </div>
            <button id="refreshBtn" class="refresh-btn" onclick="loadDraftState()">üîÑ Refresh</button>
        </div>

        <!-- Players Grid -->
        <div id="playersGrid" class="players-grid">
            <p class="loading-message">Loading available players...</p>
        </div>
    </section>
</div>

<!-- Toast Notification -->
<div id="toast" class="toast"></div>
{% endblock %}

{% block extra_scripts %}
<script>
// Global state
let draftState = null;
let availablePlayers = [];
let selectedOwner = localStorage.getItem('selectedOwner') || '';
let refreshInterval = null;
let pollInterval = 10000; // Start with 10 seconds

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    // Restore owner selection
    if (selectedOwner) {
        document.getElementById('ownerSelect').value = selectedOwner;
    }
    
    // Setup event listeners
    document.getElementById('ownerSelect').addEventListener('change', handleOwnerChange);
    document.getElementById('positionFilter').addEventListener('change', filterPlayers);
    document.getElementById('searchInput').addEventListener('input', filterPlayers);
    
    // Initial load
    loadDraftState();
    
    // Start adaptive polling
    startAdaptivePolling();
});

// Adaptive polling based on turn status
function startAdaptivePolling() {
    if (refreshInterval) {
        clearInterval(refreshInterval);
    }
    
    refreshInterval = setInterval(() => {
        loadDraftState();
        
        // Adjust polling interval based on turn
        const currentPick = draftState?.current_pick;
        const isMyTurn = currentPick && currentPick.owner_name === selectedOwner;
        const isDraftComplete = draftState?.draft_state?.draft_complete;
        
        if (isDraftComplete) {
            // Stop polling when draft is complete
            clearInterval(refreshInterval);
            console.log('Draft complete - polling stopped');
        } else if (isMyTurn) {
            // Poll faster when it's your turn (10 seconds)
            if (pollInterval !== 10000) {
                pollInterval = 10000;
                clearInterval(refreshInterval);
                startAdaptivePolling();
            }
        } else {
            // Poll slower when waiting (30 seconds)
            if (pollInterval !== 30000) {
                pollInterval = 30000;
                clearInterval(refreshInterval);
                startAdaptivePolling();
            }
        }
    }, pollInterval);
}

// Handle owner selection
function handleOwnerChange(e) {
    selectedOwner = e.target.value;
    localStorage.setItem('selectedOwner', selectedOwner);
    renderRosterGrid();
    renderPlayers();
    showToast(`Selected: ${selectedOwner || 'None'}`, 'info');
}

// Render roster grid showing required positions and filled slots
function renderRosterGrid() {
    const grid = document.getElementById('rosterGrid');
    
    if (!selectedOwner) {
        grid.innerHTML = '<p class="empty-message">Please select your name to view your roster</p>';
        return;
    }
    
    if (!draftState || !draftState.roster_requirement) {
        grid.innerHTML = '<p class="empty-message">Loading roster requirements...</p>';
        return;
    }
    
    const requirement = draftState.roster_requirement;
    const requiredPositions = requirement.positions_required.split(',').map(p => p.trim());
    const isDraftComplete = draftState.draft_state?.draft_complete;
    
    // Get current owner's drafted players
    const myTeam = draftState.teams?.find(t => t.owner_name === selectedOwner);
    const myDraftedPlayers = myTeam ? (draftState.drafted_rosters?.[myTeam.team_id] || []) : [];
    
    // Build position slots with FLEX support
    const positionSlots = [];
    const assignedPlayers = new Set();
    
    // Phase 1: Fill exact non-FLEX positions first
    requiredPositions.forEach(position => {
        const posUpper = position.toUpperCase();
        
        if (posUpper === 'FLEX' || posUpper === 'SUPERFLEX') {
            // Skip FLEX positions in first pass
            positionSlots.push({
                position: position,
                filled: false,
                player: null,
                slotIndex: positionSlots.length
            });
        } else {
            // Find exact position match
            const player = myDraftedPlayers.find(p => 
                p.position.toUpperCase() === posUpper && !assignedPlayers.has(p.player_name)
            );
            
            if (player) {
                assignedPlayers.add(player.player_name);
                positionSlots.push({
                    position: position,
                    filled: true,
                    player: player,
                    slotIndex: positionSlots.length
                });
            } else {
                positionSlots.push({
                    position: position,
                    filled: false,
                    player: null,
                    slotIndex: positionSlots.length
                });
            }
        }
    });
    
    // Phase 2: Fill FLEX positions with remaining eligible players
    positionSlots.forEach((slot, index) => {
        const posUpper = slot.position.toUpperCase();
        
        if (!slot.filled && posUpper === 'FLEX') {
            // FLEX can be filled by RB, WR, or TE
            const player = myDraftedPlayers.find(p => {
                const pPos = p.position.toUpperCase();
                return (pPos === 'RB' || pPos === 'WR' || pPos === 'TE') && 
                       !assignedPlayers.has(p.player_name);
            });
            
            if (player) {
                assignedPlayers.add(player.player_name);
                slot.filled = true;
                slot.player = player;
            }
        } else if (!slot.filled && posUpper === 'SUPERFLEX') {
            // SUPERFLEX can be filled by any offensive position
            const player = myDraftedPlayers.find(p => {
                const pPos = p.position.toUpperCase();
                return (pPos === 'QB' || pPos === 'RB' || pPos === 'WR' || pPos === 'TE') && 
                       !assignedPlayers.has(p.player_name);
            });
            
            if (player) {
                assignedPlayers.add(player.player_name);
                slot.filled = true;
                slot.player = player;
            }
        }
    });
    
    // Calculate progress
    const filled = positionSlots.filter(s => s.filled).length;
    const total = positionSlots.length;
    const progressPercent = (filled / total) * 100;
    
    // Render HTML
    grid.innerHTML = `
        <div class="roster-grid-container">
            <div class="roster-header">
                <h3>${myTeam ? myTeam.team_name : 'Your Team'}</h3>
                <div class="roster-progress">
                    <span class="progress-text">${filled}/${total} positions filled</span>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercent}%"></div>
                    </div>
                </div>
            </div>
            <div class="roster-slots">
                ${positionSlots.map(slot => `
                    <div class="roster-slot ${slot.filled ? 'filled' : 'empty'}">
                        <div class="slot-position">
                            ${slot.position}
                            ${slot.filled ? '<span class="slot-check">‚úÖ</span>' : '<span class="slot-empty">‚è≥</span>'}
                        </div>
                        <div class="slot-player">
                            ${slot.filled 
                                ? `<span class="player-name-slot">${slot.player.player_name}</span>
                                   <span class="player-team-slot">${slot.player.team}</span>
                                   ${isDraftComplete ? `<button class="draft-btn-compact" onclick="dropPlayer('${slot.player.player_name}')" style="margin-top: 8px;">üóëÔ∏è DROP</button>` : ''}` 
                                : `<span class="empty-text">Need ${slot.position}</span>`
                            }
                        </div>
                    </div>
                `).join('')}
            </div>
            <div class="roster-footer">
                <span class="payout-info">üí∞ Weekly Payout: ${requirement.payout}</span>
                <span class="teams-left-info">üë• ${requirement.teams_left} teams remaining</span>
            </div>
        </div>
    `;
}

// Load draft state from API
async function loadDraftState() {
    try {
        // Add cache buster to force fresh data
        const response = await fetch('/api/draft/state?t=' + Date.now());
        if (!response.ok) throw new Error('Failed to fetch draft state');
        
        draftState = await response.json();
        availablePlayers = draftState.available_players || [];
        
        console.log('Full draft state loaded:', JSON.stringify(draftState.draft_state, null, 2));
        
        updateUI();
        renderRosterGrid();
        renderDraftBoard();
        filterPlayers();
    } catch (error) {
        console.error('Error loading draft state:', error);
        showToast('Error loading draft state', 'error');
    }
}

// Load and render snake draft board
async function renderDraftBoard() {
    try {
        const response = await fetch('/api/draft/board?t=' + Date.now());
        if (!response.ok) throw new Error('Failed to fetch draft board');
        
        const data = await response.json();
        renderSnakeBoard(data);
        //renderRecentPicks(data);
    } catch (error) {
        console.error('Error loading draft board:', error);
        document.getElementById('snakeDraftBoard').innerHTML = '<p class="empty-message">Error loading draft board</p>';
    }
}

// Render snake draft board visualization
function renderSnakeBoard(data) {
    const board = document.getElementById('snakeDraftBoard');
    
    if (!data.rounds || data.rounds.length === 0) {
        board.innerHTML = '<p class="empty-message">No draft data available</p>';
        return;
    }
    
    // Helper function to get position color class
    const getPositionClass = (position) => {
        if (!position) return 'other';
        const pos = position.toUpperCase();
        if (pos === 'QB') return 'qb';
        if (pos === 'RB') return 'rb';
        if (pos === 'WR') return 'wr';
        if (pos === 'TE') return 'te';
        return 'other'; // K, DST
    };
    
    // Get unique team names for headers (from first round picks)
    const teamHeaders = data.rounds[0].picks.map(pick => ({
        owner: pick.owner_name,
        team: pick.team_name
    }));
    
    // Build table-style grid
    let html = `
        <div class="draft-grid-container">
            <!-- Team Headers -->
            <div class="draft-grid-header">
                <div class="round-label">Round</div>
                ${teamHeaders.map((team, idx) => `
                    <div class="team-header ${selectedOwner && team.owner === selectedOwner ? 'your-team' : ''}">
                        <div class="team-name-compact">${team.owner}</div>
                    </div>
                `).join('')}
            </div>
            
            <!-- Rounds as Rows -->
            ${data.rounds.map(round => {
                // Reverse picks for even rounds (snake draft)
                const picksToDisplay = round.round % 2 === 0 ? [...round.picks].reverse() : round.picks;
                
                return `
                    <div class="draft-grid-row">
                        <div class="round-cell">
                            <span class="round-num">R${round.round}</span>
                            <span class="round-dir">${round.round % 2 === 1 ? '‚Üí' : '‚Üê'}</span>
                        </div>
                        ${picksToDisplay.map(pick => {
                            const isYourPick = selectedOwner && pick.owner_name === selectedOwner;
                            const isCurrent = pick.is_current;
                            const isCompleted = pick.is_completed;
                            
                            let cellClass = 'pick-cell';
                            if (isCurrent) cellClass += ' current-pick';
                            if (isYourPick) cellClass += ' your-pick';
                            if (!isCompleted) cellClass += ' empty-pick';
                            
                            if (isCompleted && pick.player) {
                                const posClass = getPositionClass(pick.player.position);
                                return `
                                    <div class="${cellClass} pos-${posClass}">
                                        <span class="pos-badge-mini ${posClass}">${pick.player.position}</span>
                                        <div class="player-name-compact">${pick.player.player_name}</div>
                                    </div>
                                `;
                            } else {
                                return `
                                    <div class="${cellClass}">
                                        <div class="player-name-compact tbd">${isCurrent ? '‚è∞' : '‚Äî'}</div>
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>
                `;
            }).join('')}
        </div>
    `;
    
    board.innerHTML = html;
}

// Render recent picks feed
function renderRecentPicks(data) {
    const feedList = document.getElementById('recentPicksList');
    
    // Collect all completed picks
    const allPicks = [];
    data.rounds.forEach(round => {
        round.picks.forEach(pick => {
            if (pick.is_completed && pick.player) {
                allPicks.push({
                    ...pick,
                    round: round.round
                });
            }
        });
    });
    
    if (allPicks.length === 0) {
        feedList.innerHTML = '<p class="empty-message">No picks yet</p>';
        return;
    }
    
    // Show last 10 picks (most recent first)
    const recentPicks = allPicks.slice(-10).reverse();
    
    feedList.innerHTML = recentPicks.map(pick => {
        const posClass = pick.player.position ? pick.player.position.toLowerCase() : 'other';
        return `
            <div class="recent-pick-item">
                <div class="recent-pick-header">
                    <span class="pick-num">Pick ${pick.pick_number}</span>
                    <span class="pick-owner-name">${pick.owner_name}</span>
                </div>
                <div class="recent-pick-player">
                    <span class="player-name">${pick.player.player_name}</span>
                    <div class="player-meta">
                        <span class="pos-badge ${posClass}">${pick.player.position}</span>
                        <span class="team-name">${pick.player.nfl_team}</span>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

// Update UI with current draft state
function updateUI() {
    if (!draftState) return;
    
    const state = draftState.draft_state;
    const currentPick = draftState.current_pick;
    
    // Debug logging
    console.log('Draft State:', state);
    console.log('Draft Complete:', state.draft_complete, typeof state.draft_complete);
    
    // Update status
    const statusEl = document.getElementById('draftStatus');
    if (state.draft_complete) {
        statusEl.textContent = '‚úÖ Draft Complete - Free Agency Mode';
        statusEl.className = 'status-indicator complete';
    } else if (state.draft_started) {
        statusEl.textContent = `üî¥ Live - Round ${state.current_round}`;
        statusEl.className = 'status-indicator live';
    } else {
        statusEl.textContent = '‚è∏Ô∏è Not Started';
        statusEl.className = 'status-indicator pending';
    }
    
    // Update current pick banner
    if (currentPick) {
        document.getElementById('currentPickOwner').textContent = currentPick.owner_name;
        document.getElementById('pickDetails').textContent = 
            `Round ${currentPick.round}, Pick ${currentPick.pick}`;
        
        // Highlight if it's your turn
        const banner = document.getElementById('currentPickBanner');
        if (currentPick.owner_name === selectedOwner) {
            banner.classList.add('your-turn');
        } else {
            banner.classList.remove('your-turn');
        }
    }
}

// Filter and render players
function filterPlayers() {
    const positionFilter = document.getElementById('positionFilter').value;
    const searchQuery = document.getElementById('searchInput').value.toLowerCase();
    
    let filtered = availablePlayers.filter(p => {
        const matchesPosition = !positionFilter || p.position === positionFilter;
        const matchesSearch = !searchQuery || 
            p.player_name.toLowerCase().includes(searchQuery) ||
            p.nfl_team.toLowerCase().includes(searchQuery);
        return matchesPosition && matchesSearch;
    });
    
    renderPlayers(filtered);
}

// Render player cards with enhanced data
function renderPlayers(players = availablePlayers) {
    const grid = document.getElementById('playersGrid');
    
    if (players.length === 0) {
        grid.innerHTML = '<p class="empty-message">No players found</p>';
        return;
    }
    
    const currentPick = draftState?.current_pick;
    const isMyTurn = currentPick && currentPick.owner_name === selectedOwner;
    const isDraftComplete = draftState?.draft_state?.draft_complete;
    
    // Render condensed cards with image in top-left
    grid.innerHTML = players.map(player => {
        let buttonClass, buttonText, buttonAction, canInteract;
        
        if (isDraftComplete) {
            // Free Agency mode - anyone can add players
            canInteract = selectedOwner;
            buttonClass = canInteract ? 'draft-btn-compact' : 'draft-btn-compact disabled';
            buttonText = !selectedOwner ? 'Select Name' : '‚ûï ADD';
            buttonAction = `addPlayer('${player.player_id}', '${player.player_name}')`;
        } else {
            // Draft mode - only your turn
            canInteract = isMyTurn && selectedOwner;
            buttonClass = canInteract ? 'draft-btn-compact' : 'draft-btn-compact disabled';
            buttonText = !selectedOwner ? 'Select Name' : 
                        !isMyTurn ? 'Not Your Turn' : 'DRAFT';
            buttonAction = `draftPlayer('${player.player_id}', '${player.player_name}')`;
        }
        
        // Show FPPG from sheet or "--"
        const fppg = player.fppg ? player.fppg.toFixed(1) : '--';
        const opponent = player.opponent || '--';
        
        return `
            <div class="player-card-compact" id="player-${player.player_id}">
                <div class="player-card-header">
                    <img 
                        src="https://d17odppiik753x.cloudfront.net/playerimages/nfl/300x300/${player.player_id.split('-')[1]}.png" 
                        alt="${player.player_name}"
                        class="player-image-small"
                        onerror="this.src='/static/placeholder.png'; this.onerror=null;"
                    >
                    <div class="player-details">
                        <div class="player-name-compact">${player.player_name}</div>
                        <div class="player-meta">
                            <span class="pos-badge ${player.position.toLowerCase()}">${player.position}</span>
                            <span class="team-name">${player.nfl_team}</span>
                        </div>
                    </div>
                </div>
                <div class="player-stats-compact">
                    <div class="stat-compact">
                        <span class="stat-label-compact">FPPG</span>
                        <span class="stat-value-compact">${fppg}</span>
                    </div>
                    <div class="stat-compact">
                        <span class="stat-label-compact">vs</span>
                        <span class="stat-value-compact">${opponent}</span>
                    </div>
                </div>
                <button 
                    class="${buttonClass}"
                    onclick="${buttonAction}"
                    ${!canInteract ? 'disabled' : ''}
                >
                    ${buttonText}
                </button>
            </div>
        `;
    }).join('');
}

// Load enhanced player data from FanDuel API
async function loadPlayerEnhancedData(playerId) {
    try {
        const response = await fetch(`/api/player/${playerId}`);
        if (!response.ok) {
            console.warn(`Failed to fetch data for player ${playerId}`);
            updatePlayerStats(playerId, null);
            return;
        }
        
        const result = await response.json();
        updatePlayerStats(playerId, result.data);
    } catch (error) {
        console.error(`Error loading player data for ${playerId}:`, error);
        updatePlayerStats(playerId, null);
    }
}

// Update player card with enhanced stats
function updatePlayerStats(playerId, data) {
    const statsContainer = document.getElementById(`stats-${playerId}`);
    if (!statsContainer) return;
    
    if (!data || !data.projection) {
        // No data available
        statsContainer.innerHTML = `
            <div class="stat-item">
                <span class="stat-label">Projection:</span>
                <span class="stat-value">--</span>
            </div>
        `;
        return;
    }
    
    // Build stats HTML
    let statsHTML = '';
    
    // Projection
    if (data.projection) {
        statsHTML += `
            <div class="stat-item projection">
                <span class="stat-label">Proj:</span>
                <span class="stat-value">${data.projection} pts</span>
            </div>
        `;
    }
    
    // Opponent
    if (data.opponent) {
        statsHTML += `
            <div class="stat-item">
                <span class="stat-label">vs</span>
                <span class="stat-value">${data.opponent}</span>
            </div>
        `;
    }
    
    // Injury status
    if (data.injury_status && data.injury_status !== 'HEALTHY') {
        statsHTML += `
            <div class="stat-item injury">
                <span class="injury-badge ${data.injury_status.toLowerCase()}">${data.injury_status}</span>
            </div>
        `;
    }
    
    // Recent stats
    if (data.recent_stats) {
        statsHTML += `
            <div class="stat-item recent">
                <span class="stat-value-small">${data.recent_stats}</span>
            </div>
        `;
    }
    
    statsContainer.innerHTML = statsHTML || '<div class="stat-item">No stats available</div>';
}

// Draft a player with optimistic UI updates
async function draftPlayer(playerId, playerName) {
    console.log('draftPlayer called with:', { playerId, playerName, selectedOwner, type: typeof playerId });
    
    if (!selectedOwner) {
        showToast('Please select your name first', 'error');
        return;
    }
    
    if (!confirm(`Draft ${playerName}?`)) {
        return;
    }
    
    // Show immediate feedback
    showToast(`‚úÖ Drafting ${playerName}...`, 'info');
    
    // Disable the button immediately
    const playerCard = document.getElementById(`player-${playerId}`);
    if (playerCard) {
        const draftBtn = playerCard.querySelector('.draft-btn-compact');
        if (draftBtn) {
            draftBtn.disabled = true;
            draftBtn.textContent = 'DRAFTING...';
        }
    }
    
    try {
        // Keep playerId as string to support FanDuel hyphenated IDs like "124949-103020"
        if (!playerId || !selectedOwner) {
            console.error('Validation failed:', { playerId, selectedOwner });
            throw new Error(`Invalid player ID (${playerId}) or owner name (${selectedOwner})`);
        }
        
        const requestBody = {
            owner_name: selectedOwner,
            player_id: playerId  // Send as string
        };
        
        console.log('Sending request:', requestBody);
        
        const response = await fetch('/api/draft/pick', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
        });
        
        const data = await response.json();
        
        if (!response.ok) {
            throw new Error(data.detail || 'Draft failed');
        }
        
        showToast(`‚úÖ Successfully drafted ${playerName}!`, 'success');
        
        // Reload state after short delay
        setTimeout(loadDraftState, 300);
        
    } catch (error) {
        console.error('Error making pick:', error);
        showToast(`‚ùå Error: ${error.message}`, 'error');
        
        // Re-enable button on error
        if (playerCard) {
            const draftBtn = playerCard.querySelector('.draft-btn-compact');
            if (draftBtn) {
                draftBtn.disabled = false;
                draftBtn.textContent = 'DRAFT';
            }
        }
    }
}

// Drop a player (Free Agency)
async function dropPlayer(playerName) {
    if (!selectedOwner) {
        showToast('Please select your name first', 'error');
        return;
    }
    
    if (!confirm(`Drop ${playerName}?`)) {
        return;
    }
    
    try {
        const response = await fetch('/api/fa/drop', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                owner_name: selectedOwner,
                player_name: playerName
            })
        });
        
        const data = await response.json();
        
        if (!response.ok) {
            throw new Error(data.detail || 'Drop failed');
        }
        
        showToast(`‚úÖ Successfully dropped ${playerName}!`, 'success');
        
        // Reload state immediately
        setTimeout(loadDraftState, 500);
        
    } catch (error) {
        console.error('Error dropping player:', error);
        showToast(`Error: ${error.message}`, 'error');
    }
}

// Add a player (Free Agency)
async function addPlayer(playerId, playerName) {
    if (!selectedOwner) {
        showToast('Please select your name first', 'error');
        return;
    }
    
    if (!confirm(`Add ${playerName} to your roster?`)) {
        return;
    }
    
    try {
        const response = await fetch('/api/fa/add', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                owner_name: selectedOwner,
                player_id: playerId
            })
        });
        
        const data = await response.json();
        
        if (!response.ok) {
            throw new Error(data.detail || 'Add failed');
        }
        
        showToast(`‚úÖ Successfully added ${playerName}!`, 'success');
        
        // Reload state immediately
        setTimeout(loadDraftState, 500);
        
    } catch (error) {
        console.error('Error adding player:', error);
        showToast(`Error: ${error.message}`, 'error');
    }
}

// Show toast notification
function showToast(message, type = 'info') {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.className = `toast show ${type}`;
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, 3000);
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (refreshInterval) {
        clearInterval(refreshInterval);
    }
});
</script>
{% endblock %}
